/**
 * Generated by Apache Flex Cross-Compiler from weavejs/util/JS.as
 * weavecore.JS
 *
 * @fileoverview
 *
 * @suppress {checkTypes}
 */





/**
 * @constructor
 */
weavecore.JS = function () {};


/**
 * @private
 * @param {string} name
 * @return {*}
 */
weavecore.JS.getGlobal = function (name) {
    var /** @type {Object} */ Fn = Function;
    var /** @type {Function} */ fn = new Fn("return " + name + ";");
    return fn();
};


/**
 * @export
 * @const
 * @type {Object}
 */
weavecore.JS.global = weavecore.JS.getGlobal("window");


/**
 * @private
 * @const
 * @type {Object}
 */
weavecore.JS.console = weavecore.JS.getGlobal("console");


/**
 * @private
 * @const
 * @type {Object}
 */
weavecore.JS.Symbol = weavecore.JS.getGlobal("Symbol");


/**
 * Calls console.error()
 * @export
 * @param {...} args
 */
weavecore.JS.error = function (args) {
    args = Array.prototype.slice.call(arguments, 0);
    weavecore.JS.console.error.apply(weavecore.JS.console, args);
};


/**
 * Calls console.log()
 * @export
 * @param {...} args
 */
weavecore.JS.log = function (args) {
    args = Array.prototype.slice.call(arguments, 0);
    weavecore.JS.console.log.apply(weavecore.JS.console, args);
};


/**
 * @private
 * @const
 * @type {RegExp}
 */
weavecore.JS.unnamedFunctionRegExp = /^\s*function\s*\([^\)]*\)\s*\{.*\}\s*$/;


/**
 * Compiles a script into a function with optional parameter names.
 * @asparam script A String containing JavaScript code.
 * @asparam paramNames A list of parameter names for the generated function, so that these variable names can be used in the script.
 * @export
 * @param {string} script
 * @param {Array=} paramNames
 * @return {Function}
 */
weavecore.JS.compile = function (script, paramNames) {
    paramNames = typeof paramNames !== 'undefined' ? paramNames : null;
    var /** @type {boolean} */ isFunc = weavecore.JS.unnamedFunctionRegExp.test(script);
    if (isFunc)
        script = "(" + script + ")";
    var /** @type {Array} */ args = (paramNames || []).concat("return eval(" + JSON.stringify(script) + ");");
    var /** @type {Function} */ func = Function['apply'](null, args);
    return function () {
        try {
            return func.apply(this, arguments);
        } catch (e) {
            if (weavecore.ClassUtils.is(e, SyntaxError)) {
                args.pop();
                args.push(script);
                try {
                    func = Function['apply'](null, args);
                } catch (e2) {
                    if (weavecore.ClassUtils.is(e2, SyntaxError))
                        func = Function['apply']();
                    throw e2;
                }
                return func.apply(this, arguments);
            }
            throw e;
        }
    };
};


/**
 * @export
 * @const
 * @type {Object}
 */
weavecore.JS.Promise = weavecore.JS.getGlobal('Promise');


/**
 * @export
 * @const
 * @type {Object}
 */
weavecore.JS.Map = weavecore.JS.getGlobal('Map');


/**
 * @export
 * @const
 * @type {Object}
 */
weavecore.JS.WeakMap = weavecore.JS.getGlobal('WeakMap');


/**
 * AS->JS Language helper for getting an Array of Map keys.
 * @export
 * @param {Object} map
 * @return {Array}
 */
weavecore.JS.mapKeys = function (map) {
    return map ? weavecore.JS.toArray(map.keys()) : [];
};


/**
 * AS->JS Language helper for getting an Array of Map values.
 * @export
 * @param {Object} map
 * @return {Array}
 */
weavecore.JS.mapValues = function (map) {
    return map ? weavecore.JS.toArray(map.values()) : [];
};


/**
 * AS->JS Language helper for getting an Array of Map entries.
 * @export
 * @param {Object} map
 * @return {Array}
 */
weavecore.JS.mapEntries = function (map) {
    return map ? weavecore.JS.toArray(map.entries()) : [];
};


/**
 * Tests if an object can be iterated over. If this returns true, then toArray()
 * can be called to get all the values from the iterator as an Array.
 * @export
 * @param {*} value
 * @return {boolean}
 */
weavecore.JS.isIterable = function (value) {
    return value && typeof (value[weavecore.JS.Symbol.iterator]) === 'function';
};


/**
 * AS->JS Language helper for converting array-like objects to Arrays
 * Extracts an Array of values from an Iterator object.
 * Converts Arguments object to an Array.
 * @export
 * @param {*} value
 * @return {Array}
 */
weavecore.JS.toArray = function (value) {
    if (weavecore.ClassUtils.is(value, Array))
        return value;
    if (value && typeof (value[weavecore.JS.Symbol.iterator]) === 'function') {
        var /** @type {Object} */ iterator = value[weavecore.JS.Symbol.iterator]();
        var /** @type {Array} */ values = [];
        while (true) {
            var /** @type {Object} */ next = iterator.next();
            if (next.done)
                break;
            values.push(next.value);
        }
        return values;
    }
    if (Object.prototype.toString.call(value) === '[object Arguments]')
        return Array.prototype.slice.call(value);
    return null;
};


/**
 * AS->JS Language helper for Object.keys()
 * @export
 * @param {Object} object
 * @return {Array}
 */
weavecore.JS.objectKeys = function (object) {
    return Object['keys'](object);
};


/**
 * Tests if a value is of a primitive type.
 * @export
 * @param {*} value
 * @return {boolean}
 */
weavecore.JS.isPrimitive = function (value) {
    return value === null || typeof (value) !== 'object';
};


/**
 * Makes a deep copy of an object.
 * @export
 * @param {Object} object
 * @return {Object}
 */
weavecore.JS.copyObject = function (object) {
    if (object === null || typeof (object) !== 'object')
        return object;
    var /** @type {Object} */ copy = weavecore.ClassUtils.is(object, Array) ? [] : {};
    for (var /** @type {string} */ key in object)
        copy[key] = weavecore.JS.copyObject(object[key]);
    return copy;
};


/**
 * AS->JS Language helper for binding class instance functions
 * @private
 * @param {Object} instance
 * @return {*}
 */
weavecore.JS.bindAll = function (instance) {
    var /** @type {Object} */ proto = Object['getPrototypeOf'](instance);
    for (var /** @type {string} */ key in proto) {
        var /** @type {*} */ prop = proto[key];
        if (typeof (prop) === 'function' && key !== 'constructor')
            instance[key] = prop.bind(instance);
    }
    return instance;
};


/**
 * Implementation of "classDef is Class"
 * @export
 * @param {Object} classDef
 * @return {boolean}
 */
weavecore.JS.isClass = function (classDef) {
    return typeof (classDef) === 'function' && classDef.prototype && classDef.prototype.constructor === classDef;
};


/**
 * Implementation of "classDef as Class"
 * @export
 * @param {Object} classDef
 * @return {*}
 */
weavecore.JS.asClass = function (classDef) {
    return weavecore.JS.isClass(classDef) ? classDef : null;
};


/**
 * @export
 * @param {Function} func
 * @param {number} delay
 * @param {...} params
 * @return {number}
 */
weavecore.JS.setTimeout = function (func, delay, params) {
    params = Array.prototype.slice.call(arguments, 2);
    params.unshift(func, delay);
    return weavecore.JS.global['setTimeout'].apply(weavecore.JS.global, params);
};


/**
 * @export
 * @param {Function} func
 * @param {number} delay
 * @param {...} params
 * @return {number}
 */
weavecore.JS.setInterval = function (func, delay, params) {
    params = Array.prototype.slice.call(arguments, 2);
    params.unshift(func, delay);
    return weavecore.JS.global['setInterval'].apply(weavecore.JS.global, params);
};


/**
 * @export
 * @param {Function} func
 * @return {number}
 */
weavecore.JS.requestAnimationFrame = function (func) {
    return weavecore.JS.global['requestAnimationFrame'].call(weavecore.JS.global, func);
};


/**
 * @export
 * @param {number} id
 */
weavecore.JS.cancelAnimationFrame = function (id) {
    weavecore.JS.global['cancelAnimationFrame'].call(weavecore.JS.global, id);
};


/**
 * Current time in milliseconds
 * @export
 * @return {number}
 */
weavecore.JS.now = function () {
    return Date['now']();
};


/**
 * @private
 * @type {Object}
 */
weavecore.JS.Language;


/**
 * Fixes bugs with the "is" operator.
 * @export
 * @return {*}
 */
weavecore.JS.fix_is = function () {
    if (!weavecore.JS.Language)
        weavecore.JS.Language = weavecore.JS.getGlobal("weavecore.ClassUtils");
    weavecore.JS.Language['is'] = weavecore.JS.IS;
    if (!weavecore.ClassUtils.is(true, Boolean))
        throw new Error('"is" operator is broken');
};


/**
 * Safe version of 'as' operator
 * Using this will avoid the bug where "obj as this.classDef" compiles incorrectly as "...Language.as(obj, classDef)"
 * @export
 * @param {Object} leftOperand
 * @param {Object} rightOperand
 * @return {*}
 */
weavecore.JS.AS = function (leftOperand, rightOperand) {
    if (!weavecore.JS.Language)
        weavecore.JS.Language = weavecore.JS.getGlobal("weavecore.ClassUtils");
    return weavecore.JS.Language['as'](leftOperand, rightOperand);
};


/**
 * Bug fixes for 'is' operator, modified from weavecore.ClassUtils.is
 * - "this is Boolean" works
 * - won't compile "obj is this.classDef" incorrectly as "...Language.is(obj, classDef)"
 * @export
 * @param {Object} leftOperand
 * @param {Object} rightOperand
 * @return {boolean}
 */
weavecore.JS.IS = function (leftOperand, rightOperand) {
    var /** @type {Object} */ superClass;
    if (leftOperand == null || rightOperand == null)
        return false;
    if (leftOperand instanceof rightOperand)
        return true;
    if (rightOperand === Object)
        return true;
    if (typeof (leftOperand) === 'string')
        return rightOperand === String;
    if (typeof (leftOperand) === 'number')
        return rightOperand === Number;
    if (typeof (leftOperand) === 'boolean')
        return rightOperand === Boolean;
    if (rightOperand === Array)
        return Array['isArray'](leftOperand);
    if (leftOperand.CLASS_INFO === undefined)
        return false;
    if (leftOperand.CLASS_INFO.interfaces) {
        if (weavecore.JS._IS_checkInterfaces(leftOperand, rightOperand)) {
            return true;
        }
    }
    superClass = leftOperand.constructor.superClass_;
    if (superClass) {
        while (superClass && superClass.CLASS_INFO) {
            if (superClass.CLASS_INFO.interfaces) {
                if (weavecore.JS._IS_checkInterfaces(superClass, rightOperand)) {
                    return true;
                }
            }
            superClass = superClass.constructor.superClass_;
        }
    }
    return false;
};


/**
 * @private
 * @param {Object} leftOperand
 * @param {Object} rightOperand
 * @return {boolean}
 */
weavecore.JS._IS_checkInterfaces = function (leftOperand, rightOperand) {
    var /** @type {number} */ i, /** @type {Array} */ interfaces;
    interfaces = leftOperand.CLASS_INFO.interfaces;
    for (i = interfaces.length - 1; i > -1; i--) {
        if (interfaces[i] === rightOperand) {
            return true;
        }
        if (interfaces[i].prototype.CLASS_INFO.interfaces) {
            if (weavecore.JS._IS_checkInterfaces(interfaces[i].prototype, rightOperand))
                return true;
        }
    }
    return false;
};


/**
 * Similar to Object.hasOwnProperty(), except it also checks prototypes.
 * @export
 * @param {Object} object
 * @param {string} prop
 * @return {boolean}
 */
weavecore.JS.hasProperty = function (object, prop) {
    while (object != null && !Object['getOwnPropertyDescriptor'](object, prop))
        object = Object['getPrototypeOf'](object);
    return object != null;
};


/**
 * Similar to Object.getOwnPropertyNames(), except it also checks prototypes.
 * @export
 * @param {Object} object
 * @param {boolean} useCache
 * @return {Array}
 */
weavecore.JS.getPropertyNames = function (object, useCache) {
    if (object == null || object === Object.prototype)
        return [];
    if (useCache && weavecore.JS.map_obj_names.has(object))
        return weavecore.JS.map_obj_names.get(object);
    var /** @type {Array} */ names = weavecore.JS.getPropertyNames(Object['getPrototypeOf'](object), useCache);
    if (useCache)
        names = names.concat();
    ++weavecore.JS.skip_id;
    var /** @type {string} */ name;
    for (var foreachiter0 in names) {
        name = names[foreachiter0];

        weavecore.JS.map_prop_skip.set(name, weavecore.JS.skip_id);
    }

    var /** @type {Array} */ ownNames = Object['getOwnPropertyNames'](object);
    for (var foreachiter1 in ownNames) {
        name = ownNames[foreachiter1]; {
            if (weavecore.JS.map_prop_skip.get(name) !== weavecore.JS.skip_id) {
                weavecore.JS.map_prop_skip.set(name, weavecore.JS.skip_id);
                names.push(name);
            }
        }
    }

    weavecore.JS.map_obj_names.set(object, names);
    return names;
};


/**
 * @private
 * @const
 * @type {Object}
 */
weavecore.JS.map_obj_names = new weavecore.JS['WeakMap']();


/**
 * @private
 * @const
 * @type {Object}
 */
weavecore.JS.map_prop_skip = new weavecore.JS['Map']();


/**
 * @private
 * @type {number}
 */
weavecore.JS.skip_id = 0;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
weavecore.JS.prototype.CLASS_INFO = {
    names: [{
        name: 'JS',
        qName: 'weavecore.JS'
    }]
};
